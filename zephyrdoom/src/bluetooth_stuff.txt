#include <bluetooth/gatt_dm.h>
#include <bluetooth/scan.h>
#include <bluetooth/services/nus.h>
#include <bluetooth/services/nus_client.h>
#include <errno.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/gatt.h>
#include <zephyr/bluetooth/hci.h>
#include <zephyr/bluetooth/uuid.h>
#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/uart.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/settings/settings.h>
#include <zephyr/sys/byteorder.h>
#include <zephyr/sys/printk.h>

void ble_data_sent(struct bt_nus_client *nus, uint8_t err,
                   const uint8_t *const data, uint16_t len);
uint8_t ble_data_received(struct bt_nus_client *nus, const uint8_t *data,
                          uint16_t len);
void uart_cb(const struct device *dev, struct uart_event *evt, void *user_data);
void uart_work_handler(struct k_work *item);
int uart_init(void);
void discovery_complete(struct bt_gatt_dm *dm, void *context);
void discovery_service_not_found(struct bt_conn *conn, void *context);
void discovery_error(struct bt_conn *conn, int err, void *context);
void gatt_discover(struct bt_conn *conn);
void exchange_func(struct bt_conn *conn, uint8_t err,
                   struct bt_gatt_exchange_params *params);
void connected(struct bt_conn *conn, uint8_t conn_err);
void disconnected(struct bt_conn *conn, uint8_t reason);
void security_changed(struct bt_conn *conn, bt_security_t level,
                      enum bt_security_err err);
void scan_filter_match(struct bt_scan_device_info *device_info,
                       struct bt_scan_filter_match *filter_match,
                       bool connectable);
void scan_connecting_error(struct bt_scan_device_info *device_info);
void scan_connecting(struct bt_scan_device_info *device_info,
                     struct bt_conn *conn);
int nus_client_init(void);
int scan_init(void);
void auth_cancel(struct bt_conn *conn);
void pairing_complete(struct bt_conn *conn, bool bonded);
void pairing_failed(struct bt_conn *conn, enum bt_security_err reason);
int bluetooth_main();

/* UART payload buffer element size. */
#define UART_BUF_SIZE 20

#define KEY_PASSKEY_ACCEPT DK_BTN1_MSK
#define KEY_PASSKEY_REJECT DK_BTN2_MSK

#define NUS_WRITE_TIMEOUT K_MSEC(150)
#define UART_WAIT_FOR_BUF_DELAY K_MSEC(50)
#define UART_RX_TIMEOUT \
    50000 /* Wait for RX complete event time in microseconds. */

const struct device *uart = DEVICE_DT_GET(DT_NODELABEL(uart0));
struct k_work_delayable uart_work;

K_SEM_DEFINE(nus_write_sem, 0, 1);

struct uart_data_t {
    void *fifo_reserved;
    uint8_t data[UART_BUF_SIZE];
    uint16_t len;
};

K_FIFO_DEFINE(fifo_uart_tx_data);
K_FIFO_DEFINE(fifo_uart_rx_data);

struct bt_conn *default_conn;
struct bt_nus_client nus_client;

struct bt_gatt_dm_cb discovery_cb = {
    .completed = discovery_complete,
    .service_not_found = discovery_service_not_found,
    .error_found = discovery_error,
};

BT_CONN_CB_DEFINE(conn_callbacks) = {.connected = connected,
                                     .disconnected = disconnected,
                                     .security_changed = security_changed};

BT_SCAN_CB_INIT(scan_cb, scan_filter_match, NULL, scan_connecting_error,
                scan_connecting);

struct bt_conn_auth_cb conn_auth_callbacks = {
    .cancel = auth_cancel,
};

struct bt_conn_auth_info_cb conn_auth_info_callbacks = {
    .pairing_complete = pairing_complete, .pairing_failed = pairing_failed};